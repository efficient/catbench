From patchwork Wed Jul 13 01:02:55 2016
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [22/32] x86/intel_rdt_rdtgroup.h: Header for user interface
From: Fenghua Yu <fenghua.yu@intel.com>
X-Patchwork-Id: 9226305
Message-Id: <1468371785-53231-23-git-send-email-fenghua.yu@intel.com>
To: "Thomas Gleixner" <tglx@linutronix.de>, "Ingo Molnar" <mingo@elte.hu>,
 "H. Peter Anvin" <h.peter.anvin@intel.com>,
 "Tony Luck" <tony.luck@intel.com>, "Tejun Heo" <tj@kernel.org>,
 "Borislav Petkov" <bp@suse.de>, "Stephane Eranian" <eranian@google.com>,
 "Peter Zijlstra" <peterz@infradead.org>,
 "Marcelo Tosatti" <mtosatti@redhat.com>,
 "David Carrillo-Cisneros" <davidcc@google.com>,
 "Ravi V Shankar" <ravi.v.shankar@intel.com>,
 "Vikas Shivappa" <vikas.shivappa@linux.intel.com>,
 "Sai Prakhya" <sai.praneeth.prakhya@intel.com>
Cc: "linux-kernel" <linux-kernel@vger.kernel.org>,
 "x86" <x86@kernel.org>, "Fenghua Yu" <fenghua.yu@intel.com>
Date: Tue, 12 Jul 2016 18:02:55 -0700

From: Fenghua Yu <fenghua.yu@intel.com>

This is header file for user interface file intel_rdt_rdtgroup.c.

Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
Reviewed-by: Tony Luck <tony.luck@intel.com>
---
 arch/x86/include/asm/intel_rdt_rdtgroup.h | 226 ++++++++++++++++++++++++++++++
 1 file changed, 226 insertions(+)
 create mode 100644 arch/x86/include/asm/intel_rdt_rdtgroup.h

diff --git a/arch/x86/include/asm/intel_rdt_rdtgroup.h b/arch/x86/include/asm/intel_rdt_rdtgroup.h
new file mode 100644
index 0000000..797fed3
--- /dev/null
+++ b/arch/x86/include/asm/intel_rdt_rdtgroup.h
@@ -0,0 +1,226 @@
+#ifndef _RDT_PGROUP_H
+#define _RDT_PGROUP_H
+#define MAX_RDTGROUP_TYPE_NAMELEN	32
+#define MAX_RDTGROUP_ROOT_NAMELEN	64
+#define MAX_RFTYPE_NAME			64
+
+#include <asm/intel_rdt.h>
+
+extern void rdtgroup_exit(struct task_struct *tsk);
+
+struct pss_set {
+	void  *self;
+	/*
+	 * Lists running through all tasks using this rdtgroup.
+	 */
+	struct list_head tasks;
+
+	/* all css_task_iters currently walking this cset */
+	struct list_head task_iters;
+
+	/* Reference count */
+	atomic_t refcount;
+};
+
+/* cftype->flags */
+enum {
+	RFTYPE_WORLD_WRITABLE = (1 << 4),/* (DON'T USE FOR NEW FILES) S_IWUGO */
+
+	/* internal flags, do not use outside rdtgroup core proper */
+	__RFTYPE_ONLY_ON_DFL  = (1 << 16),/* only on default hierarchy */
+	__RFTYPE_NOT_ON_DFL   = (1 << 17),/* not on default hierarchy */
+};
+
+/* bits in struct rdtgroup flags field */
+enum {
+	/* rdtroup requires release notifications to userspace */
+	RDTGRP_NOTIFY_ON_RELEASE,
+	/*
+	 * Clone the parent's configuration when creating a new child
+	 * cpuset rdtgroup.  For historical reasons, this option can be
+	 * specified at mount time and thus is implemented here.
+	 */
+	RDTGRP_CPUSET_CLONE_CHILDREN,
+};
+
+#define CACHE_LEVEL3		3
+
+struct cache_resource {
+	u64 *cbm;
+	u64 *cbm2;
+	int *closid;
+	int *refcnt;
+};
+
+struct rdt_resource {
+	bool valid;
+	int closid[MAX_CACHE_DOMAINS];
+	/* Add more resources here. */
+};
+
+struct rdtgroup {
+	unsigned long flags;		/* "unsigned long" so bitops work */
+
+	/*
+	 * idr allocated in-hierarchy ID.
+	 *
+	 * ID 0 is not used, the ID of the root rdtgroup is always 1, and a
+	 * new rdtgroup will be assigned with a smallest available ID.
+	 *
+	 * Allocating/Removing ID must be protected by rdtgroup_mutex.
+	 */
+	int id;
+
+	/*
+	 * The depth this rdtgroup is at.  The root is at depth zero and each
+	 * step down the hierarchy increments the level.  This along with
+	 * ancestor_ids[] can determine whether a given rdtgroup is a
+	 * descendant of another without traversing the hierarchy.
+	 */
+	int level;
+
+	/*
+	 * Each non-empty css_set associated with this rdtgroup contributes
+	 * one to populated_cnt.  All children with non-zero popuplated_cnt
+	 * of their own contribute one.  The count is zero iff there's no
+	 * task in this rdtgroup or its subtree.
+	 */
+	int populated_cnt;
+
+	struct kernfs_node *kn;		/* rdtgroup kernfs entry */
+
+	struct rdtgroup_root *root;
+
+	struct list_head rdtgroup_list;
+
+	struct pss_set pset;
+	struct cpumask cpu_mask;
+	char schema[1024];
+
+	/* used to wait for offlining of csses */
+	wait_queue_head_t offline_waitq;
+
+	struct rdt_resource resource;
+
+	/* ids of the ancestors at each level including self */
+	int ancestor_ids[];
+};
+
+struct rftype {
+	/*
+	 * By convention, the name should begin with the name of the
+	 * subsystem, followed by a period.  Zero length string indicates
+	 * end of cftype array.
+	 */
+	char name[MAX_CFTYPE_NAME];
+	unsigned long private;
+
+	/*
+	 * The maximum length of string, excluding trailing nul, that can
+	 * be passed to write.  If < PAGE_SIZE-1, PAGE_SIZE-1 is assumed.
+	 */
+	size_t max_write_len;
+
+	/* CFTYPE_* flags */
+	unsigned int flags;
+
+	/*
+	 * If non-zero, should contain the offset from the start of css to
+	 * a struct rdtgroup_file field.  rdtgroup will record the handle of
+	 * the created file into it.  The recorded handle can be used as
+	 * long as the containing css remains accessible.
+	 */
+	unsigned int file_offset;
+
+	/*
+	 * Fields used for internal bookkeeping.  Initialized automatically
+	 * during registration.
+	 */
+	struct kernfs_ops *kf_ops;
+
+	/*
+	 * read_u64() is a shortcut for the common case of returning a
+	 * single integer. Use it in place of read()
+	 */
+	u64 (*read_u64)(struct rftype *rft);
+	/*
+	 * read_s64() is a signed version of read_u64()
+	 */
+	s64 (*read_s64)(struct rftype *rft);
+
+	/* generic seq_file read interface */
+	int (*seq_show)(struct seq_file *sf, void *v);
+
+	/* optional ops, implement all or none */
+	void *(*seq_start)(struct seq_file *sf, loff_t *ppos);
+	void *(*seq_next)(struct seq_file *sf, void *v, loff_t *ppos);
+	void (*seq_stop)(struct seq_file *sf, void *v);
+
+	/*
+	 * write_u64() is a shortcut for the common case of accepting
+	 * a single integer (as parsed by simple_strtoull) from
+	 * userspace. Use in place of write(); return 0 or error.
+	 */
+	int (*write_u64)(struct rftype *rft, u64 val);
+	/*
+	 * write_s64() is a signed version of write_u64()
+	 */
+	int (*write_s64)(struct rftype *rft, s64 val);
+
+	/*
+	 * write() is the generic write callback which maps directly to
+	 * kernfs write operation and overrides all other operations.
+	 * Maximum write size is determined by ->max_write_len.  Use
+	 * of_css/cft() to access the associated css and cft.
+	 */
+	ssize_t (*write)(struct kernfs_open_file *of,
+			 char *buf, size_t nbytes, loff_t off);
+};
+
+struct rdtgroup_root {
+	struct kernfs_root *kf_root;
+
+	/* Unique id for this hierarchy. */
+	int hierarchy_id;
+
+	/* The root rdtgroup.  Root is destroyed on its release. */
+	struct rdtgroup rdtgrp;
+
+	/* for rdtgrp->ancestor_ids[0] */
+	int rdtgrp_ancestor_id_storage;
+
+	/* Number of rdtgroups in the hierarchy */
+	atomic_t nr_rdtgrps;
+
+	/* A list running through the active hierarchies */
+	struct list_head root_list;
+
+	/* Hierarchy-specific flags */
+	unsigned int flags;
+
+	/* IDs for rdtgroups in this hierarchy */
+	struct idr rdtgroup_idr;
+
+	/* The name for this hierarchy - may be empty */
+	char name[MAX_RDTGROUP_ROOT_NAMELEN];
+};
+
+/* no synchronization, the result can only be used as a hint */
+static inline bool rdtgroup_is_populated(struct rdtgroup *rdtgrp)
+{
+	return rdtgrp->populated_cnt;
+}
+
+/* cft/css accessors for cftype->write() operation */
+static inline struct rftype *of_rft(struct kernfs_open_file *of)
+{
+	return of->kn->priv;
+}
+
+/* cft/css accessors for cftype->seq_*() operations */
+static inline struct rftype *seq_rft(struct seq_file *seq)
+{
+	return of_rft(seq->private);
+}
+
+#endif
