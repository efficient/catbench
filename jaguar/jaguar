#!/usr/bin/python3

from collections import namedtuple
from json import dump, JSONDecodeError, load
from re import match, split
from sys import argv, exit, stderr

def main():
	if len(argv) < 2:
		usage()

	Action = namedtuple("Action", "cmd minargs maxargs reads writes")
	act = {
		'get':  Action(get,   1, 1, True,  False),
		'help': Action(usage, 0, 0, False, False),
		'init': Action(init,  0, 0, False, True),
		'set':  Action(set,   2, 3, True,  True),
	}.get(argv[1], Action(usage, 0, 0, False, False));

	structured = None
	if act.cmd != usage:
		if len(argv) < 3:
			print('You must specify a filename.', file = stderr)
			usage()

		if len(argv) - 3 < act.minargs:
			print('Action \'{}\' expects at least {} arguments after filename'.format(argv[1], act.minargs), file = stderr)
			usage()
		elif len(argv) - 3 > act.maxargs:
			print('Action \'{}\' expects at most {} arguments after filename'.format(argv[1], act.maxargs), file = stderr)
			usage()

		if act.reads:
			try:
				file = open(argv[2], 'r')
				structured = load(file)
			except OSError:
				print('Unable to open file \'{}\''.format(argv[2]), file = stderr)
				exit(1)
			except JSONDecodeError as ex:
				print(ex, file = stderr)
				file.close()
				exit(1)
			file.close()

	save = act.cmd(structured, argv[3:])

	if act.writes:
		try:
			file = open(argv[2], 'w')
			dump(save, file, indent = '\t', sort_keys = True)
			print('', file = file)
		except OSError:
			print('Unable to open file \'{}\' for writing'.format(argv[2]), file = stderr)
			exit(1)
		file.close()

def init(parsed, args):
	root = {}
	root['meta'] = {}
	root['legend'] = {'args': {}, 'samples': {}}
	root['data'] = []
	return root

def get(parsed, args):
	print(pathlookup(parsed, args[0]))

def set(parsed, args):
	key = args[0]
	val = args[1]
	typ = None
	if len(args) == 3:
		val = args[2]
		try:
			typ = {
				'string': str,
				'integer': int,
				'fraction': float,
				'boolean': filtered_type(False),
			}[args[1]]
		except:
			print('Invalid type: must be one of: string, integer, fraction, boolean', file = stderr)
			exit(1)

	pathlookup(parsed, key, val, typ)
	return parsed

def filtered_type(obj):
	return {
		bool: lambda s: True if s.lower() == 'true' or s == '1' else False if s.lower() == 'false' or s == '0' else exec('raise ValueError(\'unable to parse bool\')'),
	}.get(type(obj), type(obj))

# Returns int if a (bracket-terminated) list subscript, str if a dict subscript, or throws an exn if invalid.
def indexfromsubscript(token):
	bracketterminated = match('(-?\d+)]', token)
	if not bracketterminated:
		return token
	return int(bracketterminated.group(1))

def pathlookup(parsed, path, replace = None, typ = None):
	ref = parsed

	parent = {}
	levels = split('\.|\[', path)
	for key in range(len(levels)):
		try:
			subscript = indexfromsubscript(levels[key])
			try:
				if replace != None and key == len(levels) - 1:
					if not typ:
						typ = filtered_type(ref[subscript])

					try:
						ref[subscript] = typ(replace)
					except:
						print('Unable to convert supplied data (incorrect type specifier?)', file = stderr)
						exit(1)
				ref = ref[subscript]
			except: # This node doesn't exist... add it?
				if replace == None:
					print('Element \'subscript\' does not exist and not mutating file', file = stderr)
					exit(1)

				if isinstance(subscript, int): # Node index
					# Expect list
					if not isinstance(parent, list):
						print('Attempted to use brackets on non-list node', file = stderr)
						exit(1)
				elif isinstance(subscript, str): # Node key
					# Expect dict
					if not isinstance(parent, dict):
						print('Attempted to use dot operator on non-map node', file = stderr)
						exit(1)
				else:
					print('BUG!', file = stderr)
					exit(1)

				if not typ:
					print('Type must be specified when adding an altogether new entry', file = stderr)
					exit(1)

				try:
					ref[subscript] = typ(replace)
					ref = ref[subscript]
				except:
					print('Unable to add data to JSON structure (incorrect type specifier?)', file = stderr)
					exit(1)
			parent = ref
		except: # Syntax error
			print('Ill-formatted path token: \'{}\''.format(levels[key]), file = stderr)
			exit(1)

	return ref

def usage():
	print('USAGE: {} <command> <filename> [argument]...'.format(argv[0]))
	exit(1)

if __name__ == '__main__':
	main()
